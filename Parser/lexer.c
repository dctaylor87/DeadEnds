//
//  DeadEnds
//
//  lexer.c -- Lexer for the DeadEnds programming language.
//
//  Created by Thomas Wetmore on 27 December 2022.
//  Last changed on 3 June 2023.
//

#include "lexer.h"
#include "y.tab.h"  // Generated by yacc or bison when processing yacc.y.

static int getToken(void);    // Instrumentable lexing function.
static int getTokenLow(void); // The lexing function.
static int inchar(void);      // Get the next character from the current file.
static void unreadchar(int c);  // Unread a character to the current file.
static bool reserved(String word, int *pval);  // Check whether an identifier is reserved.

// Global variables.
extern FILE* currentProgramFile;      // Current FILE* being parsed.
extern int currentProgramLineNumber;;  // Current line number in file being parsed.

// Define yylval here for now.
extern SemanticValue yylval;  // Defined in y.tab.c

static bool debugging = false; 

// yylex -- Interface to the yacc-generated parser. Returns an integer as the token type,
//   and in some cases sets yylval as the token value.
//--------------------------------------------------------------------------------------------------
int yylex(void)
{
    return getToken();
}

//  getToken -- return the next token. This calls the real lexer, allowing debugging and other
//   instrumentation to be added here.
//--------------------------------------------------------------------------------------------------
static int getToken(void)
{
    int tokenType = getTokenLow();
    if (debugging) {
        if (tokenType < 128) {
            printf("token: %c\n", tokenType);
            return tokenType;
        }
        switch (tokenType) {
            case IDEN: printf("token: %s\n", yylval.string); break;
            case ICONS: printf("token: %ld\n", yylval.integer); break;
            case SCONS: printf("token: %s\n", yylval.string); break;
            case FCONS: printf("token: %g\n", yylval.floating); break;
            default: printf("resrv: %s\n", yylval.string); break;
        };
    }
    return tokenType;
}

//  getTokenLow -- This is the real lexer.
//--------------------------------------------------------------------------------------------------
static int getTokenLow(void)
{
    int retval;
    CharType t;  // Type of current character.
    int c;  // Current character.
    static char tokbuf[512];  // Buffer where tokens accumulate.

    char *p = tokbuf;  // Pointer to current point in tokbuf.
    // Get by white space, including comments.
    while (true) {
        while ((t = characterType(c = inchar())) == White)
            ;
        if (c != '/') break; // Passed any whitespace not followed by a comment.
        // Handle comment if there.
        if ((c = inchar()) != '*') {
            // Not in comment. Unread last character and return /.
            unreadchar(c);
            return '/';
        }
        // Found the start of a comment. Read to its end.
        while (true) {
            while ((c = inchar()) != '*' && c != 0) ;  // Read to a *.
            if (c == 0) return 0;
            while ((c = inchar()) == '*') ;  // Allow multiple *'s.
            if (c == '/') break;
            if (c == 0) return 0;
            // Anything else continues the comment finding loop.
        }
    }

    // Got by any white space and/or comments. Now at the first character of a token.
    if (t == Letter) {
        p = (String) tokbuf;
        while (t == Letter | t == Digit || c == '_') {
            *p++ = c;
            t = characterType(c = inchar());
        }
        *p = 0;
        unreadchar(c);
        //printf("in lexer.c -- IDEN is %s\n", tokbuf);
        yylval.string = strsave((String) tokbuf);  // TODO: RESERVED WORDS GETTING IN THERE TOO
        // See if the IDEN is a reserved word.
        if (reserved((String) tokbuf, &retval)) return retval;
        return IDEN;
    }

    // Handle numbers. They can be positive or negative. They can be integers or floating point.
    if (c == '-' || t == Digit || c == '.') {
        bool whole = false;
        bool frac = false;
        int mul = 1;
        if (c == '-') {  // Hyphen could be a hypnen or a minus sign in front of a number.
            t = characterType(c = inchar());  // Read the next character to find out.
            if (c != '.' && t != Digit) {
                unreadchar(c);
                return '-';
            }
            mul = -1;
        }
        int ivalue = 0;
        while (t == Digit) {
            whole = true;
            ivalue = ivalue*10 + c - '0';  // Accumulate the integer part of the number.
            t = characterType(c = inchar());
        }

        // If the next character is not Period an integer was read.
        if (c != '.') {
            unreadchar(c);
            ivalue *= mul;
            yylval.integer = ivalue;
            return ICONS;
        }

        // Just read . at end of integer. Read next character to see what's up.
        t = characterType(c = inchar());
        float fvalue = 0.0;
        float fdiv = 1.0;
        while (t == Digit) {
            frac = true;
            fvalue = fvalue*10 + c - '0';
            fdiv *= 10;
            t = characterType(c = inchar());
        }

        // Unread character after last digit.
        unreadchar(c);
        if (!whole && !frac) {  // Is this possible.
            unreadchar(c);
            if (mul == -1) {
                unreadchar('.');
                return '-';
            } else
                return '.';
        }
        yylval.floating = mul*(ivalue + fvalue/fdiv);
        return FCONS;
    }

    // Handle string constants.
    if (c == '"') {
        p = tokbuf;
        while ((c = inchar()) != 0 && c != '"' && c != '\\')
            *p++ = c;
        if (c == 0 || c == '"') {
            *p = 0;
            yylval.string = strsave(tokbuf);
            return SCONS;
        }
        // Saw \ so this is an escaped character.
        switch (c = inchar()) {
            case 'n': *p++ = '\n'; break;
            case 't': *p++ = '\t'; break;
            case 'v': *p++ = '\v'; break;
            case 'r': *p++ = '\r'; break;
            case 'b': *p++ = '\b'; break;
            case 'f': *p++ = '\f'; break;
            case '"': *p++ = '"'; break;
            case '\\': *p++ = '\\'; break;
            case 0:
                *p = 0;
                yylval.string = strsave(tokbuf);
                return SCONS;
            default:
                *p++ = c; break;
        }
    }
    if (c == 0) return 0;
    return c;
}

// inchar -- Get the next character from the Lexer.
//--------------------------------------------------------------------------------------------------
static int inchar(void)
{
    int c = getc(currentProgramFile);
    if (c == '\n') currentProgramLineNumber++;
    if (debugging) printf("+: '%c'\n", c);
    return c == EOF ? 0 : c;
}

// unreadchar -- Return a character to the lexer.
//--------------------------------------------------------------------------------------------------
static void unreadchar(int c)
{
    if (c == 0) return;
    if (debugging) printf("-: '%c'\n", c);
    ungetc(c, currentProgramFile);
    if (c == '\n') currentProgramLineNumber--;
}

// rwordtable -- Reserved word table.
// KEEP THESE IN ALPHABETICAL ORDER FOR BINARY SEARCH.
//--------------------------------------------------------------------------------------------------
static struct {
    char *rword;
    int val;
} rwordtable[] = {
    { "break",    BREAK },
    { "call",     CALL },
    { "children",  CHILDREN },
    { "continue",  CONTINUE },
    { "else",     ELSE },
    { "elsif",    ELSIF },
    { "families", FAMILIES },
    { "fathers",  FATHERS },
    { "foreven",  FOREVEN },
    { "forfam",   FORFAM },
    { "forindiset",  FORINDISET },
    { "forindi",  FORINDI },
    { "forlist",  FORLIST_TOK },
    { "fornodes", FORNODES },
    { "fornotes", FORNOTES },
    { "forothr",  FOROTHR },
    { "forsour",  FORSOUR },
    { "func",     FUNC_TOK },
    { "if",       IF },
    { "mothers",  MOTHERS },
    { "Parents",  PARENTS },
    { "proc",     PROC },
    { "return",   RETURN },
    { "spouses",  SPOUSES },
    { "traverse", TRAVERSE },
    { "while",    WHILE },
};

static const int nrwords = ARRAYSIZE(rwordtable);

// reserved -- See if a string is a reserved word.
//--------------------------------------------------------------------------------------------------
static bool reserved (String word, int *pval)
{
    for (int i = 0; i < nrwords; i++) {
        if (eqstr(word, rwordtable[i].rword)) {
            *pval = rwordtable[i].val;
            return true;
        }   
    }
    return false;
}
