@section interp.h

@defun initializeInterpreter (Database*) @arrow{} void
Currently sets Perrors to zero; does nothing else.

@b{Should} be modified to take two arguments -- a @code{Database*} and a
@code{Context*}, then it could set the database field of the context to the
supplied database.
@end defun
@defun parseProgram (CString fileName, CString searchPath, ErrorLog *errorLog) @arrow{} Context*
Searches for @code{fileName} along @code{searchPath}.  If found, it is
parsed.  If there are no errors, a @code{Context *} is returned.
Otherwise, @code{null} is returned.  Errors are returned in
@code{errorLog}.
@end defun
@defun finishInterpreter (void) @arrow{} void
Should be called When the parse of the script program is no longer
needed, Currently does nothing.  @b{Should} be modified to take a
@code{Context*} argument and free the memory.
@end defun
@defun interpret (PNode*, Context*, PValue*) @arrow{} InterpType
The function @code{interpret} is called to interpret the previously
parsed program.
@end defun
@deftypevar bool programParsing
A boolean, @code{true} when a script is being parsed, @code{false}
otherwise.
@end deftypevar
@deftypevar bool programRunning
A boolean, @code{true} when a script is running, @code{false}
otherwise.
@end deftypevar
@deftypevar bool programDebugging
When @code{true} some debugging information is printed.
@end deftypevar

@section pnode.h

@defun procCallPNode (String, PNode*) @arrow{} PNode*
@end defun

@section pvalue.h

@deftypevar int Perrors
Counts the errors encountered while parsing the program.  For the
errors themselves, consult the @code{errorLog} argument to
@code{parseProgram}
@end deftypevar

@section sequence.h

@defun createSequence (RecordIndex* index) @arrow{} Sequence*
Creates an empty sequence and returns it.  The @code{index} is
recorded in the sequence header.
@end defun
@defun deleteSequence (Sequence* sequence) @arrow{} void
Deletes @code{sequence}, freeing its memory.
@end defun
@defun copySequence (Sequence*) @arrow{} Sequence*
@end defun
@defun lengthSequence (Sequence* sequence) @arrow{} int
Returns the length of sequence @code{sequence}.
@end defun
@defun appendToSequence (Sequence* sequence, CString key, const void* element) @arrow{} void
@end defun
@defun isInSequence (Sequence* sequence, CString key) @arrow{} bool
Checks to see if @code{key} is present in @code{sequence}.  If found,
returns @code{true}, otherwise, returns @code{false}.
@end defun
@defun removeFromSequence (Sequence* sequence, CString key) @arrow{} bool
Removes @code{key} from @code{sequence}.  Returns @code{true} if it
was successfully removed.  Returns @code{false} otherwise.
@end defun
@defun removeFromSequenceByIndex  (Sequence *sequence, int index) @arrow{} bool
Removes the sequence element having index @code{code}.  Returns
@code{true} on success, @#code{false} on failure.
@end defun
@defun nameSortSequence (Sequence* sequence) @arrow{} void
Sorts #@code{sequence} by name.  Assumes it is a sequence of person records.
@end defun
@defun personToChildren (GNode* person, RecordIndex* index) @arrow{} Sequence*
Iterates over all the families @code{person} is a spouse in and adds
all the children of each family to a sequence.  Returns the sequence.
If there are no children, returns @code{null}.
@end defun
@defun personToFathers (GNode* person, RecordIndex* index) @arrow{} Sequence*
Iterates over all the families that @code{person} is a child in and
adds the husbands to a sequence.  Returns the sequence if it is
non-empty.  Otherwise it returns @code{null}.
@end defun
@defun personToMothers (GNode* person, RecordIndex* index) @arrow{} Sequence*
Iterates over all the families that @code{person} is a child in and
adds the wives to a sequence.  Returns the sequence if it is
non-empty.  Otherwise it returns @code{null}.
@end defun
@defun familyToChildren (GNode* family, RecordIndex* index) @arrow{} Sequence*
@end defun
@defun familyToFathers (GNode* family, RecordIndex* index) @arrow{} Sequence*
@end defun
@defun familyToMothers (GNode* family, RecordIndex* index) @arrow{} Sequence*
@end defun
@defun personToSpouses (GNode* person, RecordIndex* index) @arrow{} Sequence*
@end defun
@defun personToFamilies (GNode* person, bool, RecordIndex* index) @arrow{} Sequence*
@end defun
@defun refnToSequence (CString value, RecordIndex*, RefnIndex*) @arrow{} Sequence*
@end defun
@defun stringToSequence (CString name, Database* database) @arrow{} Sequence*
@end defun
@defun ancestorSequence (Sequence*, bool close) @arrow{} Sequence*
@end defun
@defun descendentSequence (Sequence*, bool close) @arrow{} Sequence*
@end defun
@defun siblingSequence (Sequence*, bool close) @arrow{} Sequence*
@end defun
@defun elementFromSequence (Sequence* sequence, int index, CString* key, CString* name) @arrow{} bool
@end defun
@defun renameElementInSequence (Sequence* sequence, CString key) @arrow{} void
@end defun
