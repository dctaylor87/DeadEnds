@section hashtable.h

@defun createHashTable (CString(*g)(const void*), int(*c)(CString, CString), void(*d)(void*), int numBuckets) @arrow{} HashTable*
@end defun
@defun deleteHashTable (HashTable*) @arrow{} void
@end defun
@defun detailSearchHashTable (HashTable* table, CString key, int* phash, int* pindex) @arrow{} void*
@end defun
@defun searchHashTable (HashTable* table, CString key) @arrow{} void*
Searches HashTable @code{table} for @code{key}.  If found, the element
is returned.  Otherwise, @code{null} is returned.
@end defun
@defun addToHashTable (HashTable*, void* element, bool replace) @arrow{} void
@end defun
@defun firstInHashTable (HashTable*, int* bucketIndex, int* elementIndex) @arrow{} void*
Returns the first element in a hash table.  It works with
@code{nextInHashTable} to iterate the table, returning each element in
turn.
@end defun
@defun nextInHashTable (HashTable* table, int* bucketIndex, int* elementIndex) @arrow{} void*
Returns the next element in the HashTable @code{table}, using the
in/out state variables @code{bucketIndex} and @code{elementIndex} to
keep track of the state of the iteration.  If there are no more
elements, then @code{null} is returned.
@end defun
@defun lastInHashTable (HashTable* table, int* bucketIndex, int* elementIndex) @arrow{} void*
Returns the last element in the hash table @code{table}.  It works with
@code{previousInHashTable} to iterate the table.
@end defun
@defun previousInHashTable (HashTable*, int*, int*) @arrow{} void*
Returns the previous element in the hash table @code{table}, using the
in/out state variables @code{bucketIndex} and @code{elementIndex} to
keep track of the state of the iteration.  If there is no previous
element, then @code{null} is returned.
@end defun
@defun removeFromHashTable (HashTable* table, CString key) @arrow{} void
Remove the element having @code{key} from the HashTable @code{table}.
@end defun
@defun addrefHashTable (HashTable *table) @arrow{} void
increment ref. count of table
@end defun
@defun releaseHashTable (HashTable *table) @arrow{} void
decrement ref. count of table, free if zero
@end defun

@section integertable.h

@defun createIntegerTable (int numBuckets) @arrow{} IntegerTable*
Creates a hash table having the specified number of buckets.  The hash
table keys are strings, the values are integers.
@end defun
@defun incrIntegerTable (IntegerTable* table, CString key) @arrow{} void
Retrieves the HashTable @code{table} entry having key @code{key},
increments its value, and stores it back into the table.  If the
element is not found, a new element is added having having a key of
@code{key} and a value of @code{1}.
@end defun

@section list.h

@defun createList (CString(*g)(const void*), int(*c)(CString, CString), void (*d)(void*), bool sorted) @arrow{} List*
Creates an empty List having the specified getKey @code{g}, compare
@code{c}, and delete @code{d} functions.  If @code{sorted} is
@code{true}, the list is a sorted list.
@end defun
@defun deleteList (List* list) @arrow{} void
Deletes the elements in List @code{list}.  Also frees @code{list}.
@end defun
@defun lengthList (List* list) @arrow{} int
Returns the number of elements in @code{list}
@end defun
@defun isEmptyList (List* list) @arrow{} bool
Returns @code{true} if List @code{list} is empty, @code{false}
otherwise.
@end defun
@defun findInList (List* list, CString key, int* index index) @arrow{} void*
Searches @code{list} for @code{key}.  If found, it is returned and
@code{*index} is set to its index.  Otherwise, @code{null} is
returned.
@end defun
@defun getListElement (List *list, int index) @arrow{} void*
@end defun
@defun appendToList (List* list, const void* element) @arrow{} void
Appends @code{element} to the end of @code{list}, extending the list
by one element.
@end defun
@defun prependToList (List* list, const void* element) @arrow{} void
Prepends @code{element} to the start of @code{list}, pushing all other
elements down by one index.
@end defun
@defun sortList (List*) @arrow{} void
@end defun
@defun searchList (List* list, CString key, int* index) @arrow{} void*
@end defun
@defun removeFromList (List* list, int index) @arrow{} bool
Remove element having index @code{index} from List @code{list}.  All
subsequent elements are moved up by one.P
@end defun
@defun getAndRemoveFirstListElement (List*) @arrow{} void*
@end defun

@section set.h

@defun lengthSet (Set*) @arrow{} int
@end defun

@section stringtable.h

@defun createStringTable (int numBuckets) @arrow{} HashTable*
A StringTable is created with the specified number of buckets.
@end defun
@defun searchStringTable (StringTable* table, CString key) @arrow{} String
The StringTable @code{table} is searched; if @code{key} is found, its
value is returned.  Otherwise, null is returned.
@end defun
@defun addToStringTable (StringTable* table, CString key, CString value) @arrow{} void
The StringTable @code{table} is searched for @code{key}.  If found, it
is removed.  Then, regardless, @code{key} is added with a value of
@code{value}.
@end defun

@section zstr.h
The functions in this section are present because the LifeLines user
interface used them and it was considered too much work to remove them
during the port effort.  They should not be used in new code as they
@b{might} be removed in the future.

@defun zs_new (void) @arrow{} ZSTR
@end defun
@defun zs_newn (unsigned int min) @arrow{} ZSTR
@end defun
@defun zs_news (const char * str) @arrow{} ZSTR
@end defun
@defun zs_newf (const char * fmt, ...) @arrow{} ZSTR
@end defun
@defun zs_newvf (const char * fmt, va_list args) @arrow{} ZSTR
@end defun
@defun zs_newsubs (const char * str, unsigned int len) @arrow{} ZSTR
@end defun
@defun zs_free (ZSTR * pzstr) @arrow{} void
@end defun
@defun zs_move (ZSTR zstr, ZSTR * pzsrc) @arrow{} void
@end defun
@defun zs_str (ZCSTR) @arrow{} char*
@end defun
@defun zs_len (ZCSTR zstr) @arrow{} unsigned int
@end defun
@defun zs_allocsize (ZCSTR zstr) @arrow{} unsigned int
@end defun
@defun zs_chop (ZSTR zstr, unsigned int len) @arrow{} void
@end defun
@defun zs_set_len (ZSTR zstr, unsigned int len) @arrow{} char*
@end defun
@defun zs_sets (ZSTR zstr, const char *) @arrow{} char*
@end defun
@defun zs_setz (ZSTR zstr, ZCSTR zsrc) @arrow{} char*
@end defun
@defun zs_apps (ZSTR zstr, const char *) @arrow{} char*
@end defun
@defun zs_appz (ZSTR zstr, ZCSTR zrc) @arrow{} char*
@end defun
@defun zs_appc (ZSTR zstr, char) @arrow{} char*
@end defun
@defun zs_setf (ZSTR zstr, const char * fmt, ...) @arrow{} char*
@end defun
@defun zs_appf (ZSTR zstr, const char * fmt, ...) @arrow{} char*
@end defun
@defun zs_clear (ZSTR zstr) @arrow{} char*
@end defun
@defun zs_reserve (ZSTR zstr, unsigned int min) @arrow{} char*
@end defun
